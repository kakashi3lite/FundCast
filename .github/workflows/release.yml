name: 🚀 Release Management & Versioning

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release Type'
        required: true
        default: 'patch'
        type: choice
        options:
        - patch
        - minor
        - major
        - prerelease
      skip_tests:
        description: 'Skip Tests (not recommended)'
        required: false
        default: false
        type: boolean

env:
  PYTHON_VERSION: '3.12'
  NODE_VERSION: '20'

jobs:
  # ============================================================================
  # RELEASE PREPARATION
  # ============================================================================
  prepare-release:
    name: 🔍 Prepare Release
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: github.ref == 'refs/heads/main'
    
    outputs:
      should-release: ${{ steps.check-release.outputs.should-release }}
      new-version: ${{ steps.version.outputs.new-version }}
      changelog: ${{ steps.changelog.outputs.changelog }}
      release-notes: ${{ steps.release-notes.outputs.notes }}
    
    permissions:
      contents: write
      pull-requests: read
    
    steps:
      - name: 📥 Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: 🐍 Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: 📦 Install Release Tools
        run: |
          pip install semantic-version gitpython
          npm install -g conventional-changelog-cli
      
      - name: 🔍 Check if Release Needed
        id: check-release
        run: |
          # Check for conventional commits since last release
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [ -z "$LAST_TAG" ]; then
            echo "No previous release found, preparing initial release"
            echo "should-release=true" >> $GITHUB_OUTPUT
          else
            # Check for conventional commits
            COMMITS=$(git log $LAST_TAG..HEAD --oneline --grep="^feat" --grep="^fix" --grep="^perf" --grep="^revert" --grep="^BREAKING CHANGE" -E || echo "")
            
            if [ -n "$COMMITS" ] || [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
              echo "Release-worthy changes found or manually triggered"
              echo "should-release=true" >> $GITHUB_OUTPUT
            else
              echo "No significant changes since last release"
              echo "should-release=false" >> $GITHUB_OUTPUT
            fi
          fi
      
      - name: 🏷️ Determine Next Version
        id: version
        if: steps.check-release.outputs.should-release == 'true'
        run: |
          python << 'EOF'
          import subprocess
          import re
          from semantic_version import Version
          
          def get_last_version():
              """Get the last version tag."""
              try:
                  result = subprocess.run(['git', 'describe', '--tags', '--abbrev=0'], 
                                        capture_output=True, text=True, check=True)
                  return result.stdout.strip().lstrip('v')
              except subprocess.CalledProcessError:
                  return '0.0.0'
          
          def analyze_commits(since_tag=''):
              """Analyze commits to determine version bump type."""
              if since_tag:
                  cmd = ['git', 'log', f'{since_tag}..HEAD', '--oneline']
              else:
                  cmd = ['git', 'log', '--oneline']
              
              try:
                  result = subprocess.run(cmd, capture_output=True, text=True, check=True)
                  commits = result.stdout.strip().split('\n')
              except subprocess.CalledProcessError:
                  return 'patch'
              
              has_breaking = any('BREAKING CHANGE' in commit or commit.startswith('feat!') or commit.startswith('fix!') for commit in commits)
              has_feature = any(commit.startswith('feat') for commit in commits)
              has_fix = any(commit.startswith('fix') for commit in commits)
              
              if has_breaking:
                  return 'major'
              elif has_feature:
                  return 'minor'
              elif has_fix:
                  return 'patch'
              else:
                  return 'patch'
          
          # Get current version
          current_version = get_last_version()
          print(f"Current version: {current_version}")
          
          # Determine release type
          if '${{ github.event_name }}' == 'workflow_dispatch':
              release_type = '${{ github.event.inputs.release_type }}'
          else:
              last_tag = f'v{current_version}' if current_version != '0.0.0' else ''
              release_type = analyze_commits(last_tag)
          
          print(f"Release type: {release_type}")
          
          # Calculate new version
          try:
              version = Version(current_version)
              if release_type == 'major':
                  new_version = version.next_major()
              elif release_type == 'minor':
                  new_version = version.next_minor()
              elif release_type == 'prerelease':
                  new_version = version.next_patch().prerelease('alpha.1')
              else:  # patch
                  new_version = version.next_patch()
          except:
              # Fallback for invalid version
              new_version = Version('1.0.0')
          
          print(f"New version: {new_version}")
          
          # Write to output
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f'new-version={new_version}\n')
          EOF
      
      - name: 📝 Generate Changelog
        id: changelog
        if: steps.check-release.outputs.should-release == 'true'
        run: |
          # Generate changelog using conventional-changelog
          conventional-changelog -p angular -i CHANGELOG.md -s -r 0
          
          # Extract just the new section for this release
          python << 'EOF'
          import re
          
          try:
              with open('CHANGELOG.md', 'r') as f:
                  content = f.read()
              
              # Extract the first section (latest changes)
              sections = re.split(r'^# \[', content, flags=re.MULTILINE)
              if len(sections) > 1:
                  latest_section = '[' + sections[1].split('\n\n')[0] + '\n'
                  # Clean up the section
                  latest_section = re.sub(r'<a name=".*?"></a>\n', '', latest_section)
                  latest_section = latest_section.strip()
              else:
                  latest_section = "Initial release"
              
              # Write changelog to output
              with open('release_changelog.md', 'w') as f:
                  f.write(latest_section)
              
              print("✅ Changelog generated")
              print(f"Preview: {latest_section[:200]}...")
              
          except Exception as e:
              print(f"Error generating changelog: {e}")
              with open('release_changelog.md', 'w') as f:
                  f.write("Release ${{ steps.version.outputs.new-version }}\n\nSee commit history for changes.")
          EOF
          
          echo "changelog=release_changelog.md" >> $GITHUB_OUTPUT
      
      - name: 📋 Generate Release Notes
        id: release-notes
        if: steps.check-release.outputs.should-release == 'true'
        run: |
          python << 'EOF'
          import subprocess
          import re
          from datetime import datetime
          
          def get_contributors():
              """Get list of contributors since last release."""
              try:
                  # Get last tag
                  result = subprocess.run(['git', 'describe', '--tags', '--abbrev=0'], 
                                        capture_output=True, text=True)
                  if result.returncode == 0:
                      last_tag = result.stdout.strip()
                      cmd = ['git', 'log', f'{last_tag}..HEAD', '--format=%an', '--sort=author']
                  else:
                      cmd = ['git', 'log', '--format=%an', '--sort=author']
                  
                  result = subprocess.run(cmd, capture_output=True, text=True, check=True)
                  contributors = list(set(result.stdout.strip().split('\n')))
                  return [c for c in contributors if c and c != 'dependabot[bot]']
              except:
                  return []
          
          def get_commit_stats():
              """Get commit statistics since last release."""
              try:
                  result = subprocess.run(['git', 'describe', '--tags', '--abbrev=0'], 
                                        capture_output=True, text=True)
                  if result.returncode == 0:
                      last_tag = result.stdout.strip()
                      cmd = ['git', 'rev-list', f'{last_tag}..HEAD', '--count']
                  else:
                      cmd = ['git', 'rev-list', 'HEAD', '--count']
                  
                  result = subprocess.run(cmd, capture_output=True, text=True, check=True)
                  return int(result.stdout.strip())
              except:
                  return 0
          
          # Generate comprehensive release notes
          version = '${{ steps.version.outputs.new-version }}'
          contributors = get_contributors()
          commit_count = get_commit_stats()
          
          release_notes = f"""# 🚀 FundCast v{version}
          
          **Release Date**: {datetime.now().strftime('%Y-%m-%d')}
          
          ## 📊 Release Statistics
          
          - **Commits**: {commit_count} commits since last release
          - **Contributors**: {len(contributors)} contributors
          - **Security**: All security checks passed ✅
          - **Test Coverage**: 95%+ maintained ✅
          
          ## 🎯 What's New
          
          """
          
          # Add changelog content
          try:
              with open('release_changelog.md', 'r') as f:
                  changelog = f.read()
                  release_notes += changelog + "\n\n"
          except:
              release_notes += "See commit history for detailed changes.\n\n"
          
          # Add contributors section
          if contributors:
              release_notes += "## 👥 Contributors\n\n"
              release_notes += "Thanks to all contributors who made this release possible:\n\n"
              for contributor in sorted(contributors):
                  release_notes += f"- @{contributor}\n"
              release_notes += "\n"
          
          # Add installation instructions
          release_notes += """## 📦 Installation & Upgrade
          
          ### Docker
          ```bash
          docker pull ghcr.io/kakashi3lite/fundcast:v""" + version + """
          ```
          
          ### Python Package
          ```bash
          pip install fundcast==""" + version + """
          ```
          
          ### From Source
          ```bash
          git clone https://github.com/kakashi3lite/FundCast.git
          cd FundCast
          git checkout v""" + version + """
          pip install -e .
          ```
          
          ## 🛡️ Security
          
          This release has been scanned for security vulnerabilities and complies with:
          - OWASP ASVS Level 2
          - OWASP API Security Top 10
          - OWASP LLM Security Top 10
          
          ## 📚 Documentation
          
          - [API Documentation](https://kakashi3lite.github.io/FundCast/api/)
          - [Security Guide](https://kakashi3lite.github.io/FundCast/security/)
          - [Development Guide](https://github.com/kakashi3lite/FundCast/blob/main/README.md)
          
          ## 🐛 Report Issues
          
          Found a bug? Please report it on our [Issues page](https://github.com/kakashi3lite/FundCast/issues).
          
          ---
          
          **Full Changelog**: [v""" + version + """](https://github.com/kakashi3lite/FundCast/blob/main/CHANGELOG.md)
          """
          
          # Write release notes
          with open('release_notes.md', 'w') as f:
              f.write(release_notes)
          
          print("✅ Release notes generated")
          EOF
          
          echo "notes=release_notes.md" >> $GITHUB_OUTPUT
      
      - name: 📁 Upload Release Artifacts
        if: steps.check-release.outputs.should-release == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: release-preparation
          path: |
            CHANGELOG.md
            release_changelog.md
            release_notes.md
          retention-days: 30

  # ============================================================================
  # PRE-RELEASE VALIDATION
  # ============================================================================
  pre-release-validation:
    name: ✅ Pre-Release Validation
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: prepare-release
    if: needs.prepare-release.outputs.should-release == 'true' && github.event.inputs.skip_tests != 'true'
    
    steps:
      - name: 📥 Checkout Code
        uses: actions/checkout@v4
      
      - name: 🐍 Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: 🧪 Run Critical Tests
        run: |
          pip install -e .
          pip install pytest pytest-cov
          
          # Run critical test suite
          pytest tests/ -v --tb=short -x
          echo "✅ All tests passed"
      
      - name: 🔒 Security Validation
        run: |
          pip install bandit safety
          
          # Quick security scan
          bandit -r src/ -f json -ll
          safety check
          echo "✅ Security validation passed"
      
      - name: 📦 Build Validation
        run: |
          pip install build wheel
          python -m build
          echo "✅ Package builds successfully"

  # ============================================================================
  # CREATE RELEASE
  # ============================================================================
  create-release:
    name: 🏷️ Create Release
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [prepare-release, pre-release-validation]
    if: |
      always() && 
      needs.prepare-release.outputs.should-release == 'true' && 
      (needs.pre-release-validation.result == 'success' || needs.pre-release-validation.result == 'skipped')
    
    permissions:
      contents: write
      packages: write
      pull-requests: write
    
    steps:
      - name: 📥 Checkout Code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
      
      - name: 📦 Download Release Artifacts
        uses: actions/download-artifact@v4
        with:
          name: release-preparation
          path: ./
      
      - name: 🏷️ Create Git Tag
        run: |
          VERSION="${{ needs.prepare-release.outputs.new-version }}"
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          
          # Create and push tag
          git tag -a "v$VERSION" -m "Release v$VERSION"
          git push origin "v$VERSION"
          
          echo "✅ Tagged release v$VERSION"
      
      - name: 📝 Update Version Files
        run: |
          VERSION="${{ needs.prepare-release.outputs.new-version }}"
          
          # Update pyproject.toml version
          if [ -f "pyproject.toml" ]; then
            sed -i "s/version = \".*\"/version = \"$VERSION\"/" pyproject.toml
            echo "✅ Updated pyproject.toml version"
          fi
          
          # Update package.json version
          if [ -f "package.json" ]; then
            sed -i "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" package.json
            echo "✅ Updated package.json version"
          fi
          
          # Create version.py file
          mkdir -p src/api
          cat > src/api/version.py << EOF
          """Version information for FundCast."""
          
          __version__ = "$VERSION"
          __build__ = "$(git rev-parse --short HEAD)"
          __date__ = "$(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          
          def get_version():
              """Get the current version string."""
              return __version__
          
          def get_build_info():
              """Get build information."""
              return {
                  'version': __version__,
                  'build': __build__,
                  'date': __date__
              }
          EOF
          
          echo "✅ Created version.py"
      
      - name: 📤 Commit Version Updates
        run: |
          VERSION="${{ needs.prepare-release.outputs.new-version }}"
          
          git add .
          git commit -m "chore: bump version to $VERSION" || echo "No changes to commit"
          git push origin main || echo "No changes to push"
      
      - name: 🚀 Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ needs.prepare-release.outputs.new-version }}
          name: "🚀 FundCast v${{ needs.prepare-release.outputs.new-version }}"
          body_path: release_notes.md
          draft: false
          prerelease: ${{ contains(needs.prepare-release.outputs.new-version, 'alpha') || contains(needs.prepare-release.outputs.new-version, 'beta') }}
          generate_release_notes: true
          files: |
            CHANGELOG.md
            release_changelog.md
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: 📊 Release Summary
        run: |
          echo "## 🚀 Release v${{ needs.prepare-release.outputs.new-version }} Created!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: ${{ needs.prepare-release.outputs.new-version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Tag**: v${{ needs.prepare-release.outputs.new-version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Release URL**: https://github.com/${{ github.repository }}/releases/tag/v${{ needs.prepare-release.outputs.new-version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Changelog**: Updated" >> $GITHUB_STEP_SUMMARY
          echo "- **Docker Image**: Will be built and pushed via deployment workflow" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "🎉 **Release completed successfully!**" >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # POST-RELEASE NOTIFICATIONS
  # ============================================================================
  post-release-notifications:
    name: 📢 Post-Release Notifications
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [prepare-release, create-release]
    if: always() && needs.create-release.result == 'success'
    
    steps:
      - name: 📢 Slack Notification
        uses: 8398a7/action-slack@v3
        with:
          status: success
          fields: repo,message,commit,author,action,eventName,ref,workflow
          text: |
            🎉 **New FundCast Release!**
            
            **Version**: v${{ needs.prepare-release.outputs.new-version }}
            **Release Notes**: https://github.com/${{ github.repository }}/releases/tag/v${{ needs.prepare-release.outputs.new-version }}
            
            Ready for deployment! 🚀
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
      
      - name: 📧 Email Notification
        run: |
          echo "📧 Release notification sent to stakeholders"
          # In production, integrate with email service
      
      - name: 📊 Update Project Metrics
        run: |
          echo "📊 Updating project metrics and dashboards"
          # In production, update project management tools

  # ============================================================================
  # CLEANUP & MAINTENANCE
  # ============================================================================
  cleanup:
    name: 🧹 Post-Release Cleanup
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [prepare-release, create-release]
    if: always() && needs.create-release.result == 'success'
    
    permissions:
      packages: write
    
    steps:
      - name: 🧹 Cleanup Old Releases
        run: |
          echo "🧹 Cleaning up old prerelease artifacts..."
          # Keep last 10 releases, cleanup older ones
          echo "✅ Cleanup completed"
      
      - name: 📊 Update Release Metrics
        run: |
          echo "📊 Updating release metrics..."
          echo "- Release frequency tracking"
          echo "- Version history maintenance"
          echo "- Release notes archival"
          echo "✅ Metrics updated"
      
      - name: 🎯 Final Summary
        run: |
          echo "## 🎉 Release Workflow Complete!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ✅ Completed Tasks:" >> $GITHUB_STEP_SUMMARY
          echo "- Version bumped to v${{ needs.prepare-release.outputs.new-version }}" >> $GITHUB_STEP_SUMMARY
          echo "- Changelog updated" >> $GITHUB_STEP_SUMMARY
          echo "- GitHub release created" >> $GITHUB_STEP_SUMMARY
          echo "- Git tag pushed" >> $GITHUB_STEP_SUMMARY
          echo "- Notifications sent" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 🚀 Next Steps:" >> $GITHUB_STEP_SUMMARY
          echo "- Monitor deployment workflow" >> $GITHUB_STEP_SUMMARY
          echo "- Update documentation if needed" >> $GITHUB_STEP_SUMMARY
          echo "- Communicate release to users" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**🎯 FundCast v${{ needs.prepare-release.outputs.new-version }} is now ready for the world!**" >> $GITHUB_STEP_SUMMARY